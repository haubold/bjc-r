<!DOCTYPE html>
<html>
	<head>
		<!-- put the following in exactly --><script type="text/javascript" src="/bjc-r/llab/loader.js"></script><title>Algorithms in BYOB</title><!--ORIGINAL NAME: Algorithms in BYOB-->
	</head>
	<body>
		Unter der Nutzung <a href="/bjc-r/prog/BYOB/algorithms-framework.ypr">des zur Verfügung gestellten Frameworks</a>, implementiere einen BYOB-Block in dem <span style="font-weight: bold;">unsortierten</span>-Sprite, der eine Zahl in einer Liste von unsortierten Nummern mit der besprochenen Strategie findet. Der Block sollte die erzielte Zahl (die "Nadel") und eine Liste von Nummern (den "Heuhaufen") als Argumente bekommen und den Index der Zahl zurückgeben. Was war die besprochene Strategie und wie könnte man sie in BYOB implementieren? Fülle einen anderen Block für den Ansatz für sortierte Listen aus und implementiere auch ihn. Benutze das Framework, um herauszufinden, wie sich ihre Laufzeit mit der Anzahl an Nummern verändert. Welcher ist schneller für eine Liste mit der Größe 5? 50? 500? 5000? Warum?
		<br>
		<br>
		<div style="text-align: center;"><img border="0" title="Blocks to build" alt="Blocks to build" src="/bjc-r/img/list/find-number-in-list.png" origsrc="http://veritas.eecs.berkeley.edu/courses/file.php/17/finder-blocks.png">
			<br>
		</div>
		<br>
		<h3>Unsortierte Daten durchsuchen</h3>
		Unsortierte Daten bieten einem nicht viel. Deine Kenntnis ist auf das Wesentlichste beschränkt: die Zahlen an sich. Das macht die Strategie eigentlich keine; das Beste, was du tun kannst, ist einfach die Liste von Anfang bis Ende Schritt für Schritt durchzugehen. Das ganze kann ziemlich langsam sein, wenn man sehr viele Zahlen durchsuchene möchte, ist aber bei kleinen Datenmengen tatsächlich sehr schnell. Zusätzlich ist der Ansatz sehr einfach gehalten und erfordert kein sortieren der Daten. Der Block sollte die Stelle der Zahl in der Liste oder Null, falls die Zahl in ihr nicht existiert, zurückgeben.
		<br>
		<h3>Sortierte Daten durchsuchen</h3><img border="0" style="float: right; display: inline;" src="/bjc-r/img/sys/binary-search-diagram.png" alt="Searching for Numbers" title="Searching for Numbers" origsrc="http://veritas.eecs.berkeley.edu/courses/file.php/17/binary-search.png">
		<br>
		Man könnte sagen, dass die Daten in eine bestimmte Ordnung (niedrigste =&gt; höchste, z.B.) tatsächlich neue Information erzeugt. Statt eine einfache Liste von Zahlen zu sein, fügt das Sortieren eine Ordnung hinzu und erlaubt es uns zusätzliche Annahmen zu machen, die wir vorher nicht zutreffend waren. Diese Art von Information ist anders als die der Zahlen selbst: sie ist nicht in einer Variable oder Liste aufbewahrt, aber wird eine <span style="font-style: italic;">Eigenschaft</span> der Information selbst. Wir können sie dazu nutzen, die Anzahl an Überprüfungen, die wir benötigen, um eine bestimmte Zahl zu finden, zu reduzieren. Der trade-off ist, dass wir sie dafür erst sortieren müssen (was Zeit in Anspruch nimmt).
		<br>
		<br>
		Das zur Verfügung gestellte Framework enthält <img border="0" title="Sort" alt="Sort" src="/bjc-r/img/list/sort-block.png" origsrc="http://veritas.eecs.berkeley.edu/courses/file.php/17/sort.png">, was uns erlaubt, eine Liste zu sortieren. Die Liste zu sortieren dauert ein bisschen, also möchten wir das so selten, wie möglich machen. Wie oft werden wir die Liste in jedem Testlauf sortieren müssen?
		<br>
		<br>
		Searching through sorted data, while faster, also requires a more complicated block. We won't need to search through every space in the list anymore -- we can assume that many of them won't work. We can keep track of the range of numbers in a list that are a possible solution to the problem (see diagram) by recording the minimum and maximum slots that could possibly contain our number. This range should shrink after each guess because you can throw away the half of the numbers on the wrong side of the center point. Here's how things should generally work:
		<br>
		<ol>
			<li>
				The range of possibilities starts off including every number in the list (the minimum is position #1 and the maximum is the final position). Let's say that we're searching for the number 33 as shown in the diagram. Start your search around the middle of the list. Check the value of the number there.
			</li>
			<li>
				If the number at the spot you searched is greater than 33, set the maximum to the slot before the one you just searched (after all, 33 CAN'T be on the larger side if it's is smaller than the one you just checked!). If the number is smaller than 33, set the minimum to the slot after the one you searched.
			</li>
			<li>
				Check the middle position of your new range. Repeat step 2 for this new range and reduce the range further.
			</li>
			<li>
				Continue to repeat steps 2 &amp; 3 until either (a) you find the number you're looking for or (b) you get in a position where the minimum and maximum of the range are equivalent without finding the number. If (b) happens, it means that the number doesn't exist in the list.
				<br>
			</li>
		</ol>
		<br>
		<h3>Flying Even Higher</h3>Let&rsquo;s say this application is going to be used to find many numbers every time it is launched -- possibly the same number multiple times. How could we speed this process up even more?
		<br>
	</body>
</html>
