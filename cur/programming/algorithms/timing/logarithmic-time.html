<!DOCTYPE html>
<html><head><!-- put the following in exactly -->

<script type="text/javascript" src="/bjc-r/llab/loader.js"></script><title>Logarithmic-Time</title><!--ORIGINAL NAME: Logarithmic-Time--></head><body>
<p>Diese Sektion beenden wir mit einer anderen Art von Laufzeit, die oft bei der Analyse von Algorithmen auftritt.
<a href="/bjc-r/cur/programming/algorithms/algorithms-in-snap.html">Zwei Sektionen früher</a> haben wir ein paar
Wege betrachtet, eine Zahl in einer Liste zu finden.
<a href="/bjc-r/cur/programming/algorithms/timing/quiz-searching-through-time.html">Wir fanden heraus</a>, dass ein Algorithmus, der lediglich eine Liste durchläuft ein Linearzeit-Algorithmus ist. (Dieser Algorithmus ist übrigens auch
als <em>linear search</em> bekannt. Nun weißt du, warum.) Wieauchimmer, die ewige Frage: Geht das noch besser?</p>
<p>Wir fanden auch einen Algorithmus, der für sortierte Listen funktioniert: wir teilten die Liste in immer kleinere
Hälften immer das mittlere Element heraussuchend, um den Suchraum zu verkleinern. Was ist die Laufzeit dieses Algorithmus?
Naja, er ist definitiv keine Operation in Konstantzeit, weil er für längere Listen länger braucht als für kurze.
Die Laufzeit wächst aber auch nicht linear, weil wir nicht alle Elemente in der Liste durchsuchen müssen.
Die Laufzeit muss also irgendwo dazwischen liegen.</p>
<p>Lasst uns zählen, wie oft wir die Liste geteilt haben. Für eine Liste der Größe 4 müssen wir nur zwei Teilungen
durchführen, bevor wir die Zahl finden oder sicherstellen können, dass sie sich nicht in der Liste befindet. Bei
einer Liste der Größe 8 haben wir nach der ersten Teilung eine Liste der Größe 4, für die wir noch, so wie eben
gezeigt, noch höchstens zwei Teilungen durchführen müssen. Bei einer Liste der Größe 16 haben wir nach einer
Teilung eine Liste der Größe 8, für die wir höchstens noch drei Teilungen durchführen müssen. Zusammengefasst:</p>
<table id="t5m:" style="font-size: 1em; line-height: inherit; border-collapse: collapse;" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody><tr style="text-align: left;"><td width="20%">Size of list</td><td width="20%"><code>4</code></td><td width="20%"><code>8</code></td><td width="20%"><code>16</code></td><td width="20%"><code>32</code></td></tr><tr style="text-align: left;"><td width="20%">Number of splits</td><td width="20%"><code>2</code></td><td width="20%"><code>3</code></td><td width="20%"><code>4</code></td><td width="20%"><code>5</code></td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;Notice
that when the size of the input doubles, the number of splits (and thus
the runtime of the algorithm) increases by one. Also, notice that the
top row is growing much faster than the bottom row. This behavior is
similar to that of the logarithmic function that you may have seen
before, where every multiplicative increase in the input is converted
to an additive increase in the output. Such a growth is thus called a <em>logarithmic</em> growth, and this algorithm is a <strong>logarithmic-time</strong> algorithm.&nbsp; (In contrast to the linear search algorithm, this algorithm is known as a <strong>binary search</strong>.)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Logarithmic-time algorithms are also
sought-after, since their runtimes are close to, although not quite,
constant-time. You can increase the sizes of their inputs by a large
factor, yet their running time will increase by a small, <em>added</em>
amount, which makes them valuable. In general, any algorithm that
involves dividing something into smaller pieces can be a
logarithmic-time algorithm.</p>   </body></html>
